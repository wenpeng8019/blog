---
layout: default
title: 素数的规律
date:   2022-04-16
math: true
tags:
- 素数
---


> 本质是缩放与累积的协同错位插值。它一方面形成了累积性，另一方面也产生了无关性。因此，素数是构成时空的基础。

## 奇数、偶数和素数

设全体数集 R 为除了 1 以外的自然数；

设除了 2 以外的素数集合为 P；所有奇数集合为 O；偶数集合为 E；



### 基本规律

$$
\begin{cases}
E = 2^t \times O\\
O = P \bigcup P \times P^{'} \times P^{''} \times \cdots
\end{cases}
$$

* 所有偶数都可以表示为：2 的幂次方乘以一个奇数。
* 所有奇数都可以表示为：要么是素数、要么是（不同）素数的乘积。
  * 注意，这里 $P \le P^{'} \le P^{''}$




### 非素奇数

非素奇数是指除了素数以外的所有奇数的集合，用 Q 来表示

根据上面的规律可知，非素奇数都可以表示为：（不同）素数的乘积。

此外，还可以等价的看成

* $ Q = P \times P^{'} \bigcup P \times Q{'}$
  * 即两个素数乘积、或一个素数和另一个非素奇数的乘积
  * 非素奇数具有递归性
* $ Q = P + P + P + \cdots \quad (数量为 P^{'} 或 Q^{'})$



### 奇数的等价表达式

在组成奇数的所有计算公式中，有一类特殊的表达式。即只由 2 和 3 通过计算构成

$$
\begin{cases}
3 \times a + 2 \times b & (a \in [1,O]) \\
2 \times n + 3 & (n \in [1,R]) \\
3  \times m \bigcup 3 \times m + 2 \bigcup 3\times m + 2 + 2 & (m \in [1,O])
\end{cases}
$$

这里，我们将第三个公式中的后两个集合和并，写成

$$
3\times m + [2, 4] \quad (m \in [1,O])
$$



## 原子数、关系数和非关系数

如果以更本质的视角来看待自然数，那么自然数可以被分为原子数、关系数和非关系数这三类

其中的原子数就是自然数 1，也就是增量的基。剩下的数都是由 1 连续递增得到的。

关系数的意思是指，该数可被分解为多个数的乘积，我们也称它为合数。对应的，非关系数就是指不可被分解的数，根据定义，它就是我们所说的素数。

因此，我们也可以将 1 以外的自然数，看成是关系数（合数）和非关系数（素数）的集合。



## 协同插值规律

根据 “素数是缩放与累积的协同错位插值” 的特性，我们可以得到素数的生成方式。



```python
# 从最基本的基数 2 开始
2: 4
1: 2
# 这里 2 和 4 之间需要一个新生的唯一性插值，因此 3 为素数。这里我们将 3 作为一个新的独立维度，即新的基数
2: 4  6
  (3) 
1: 2  3
# 此时，两个基数 2、3 乘以 2 后，得到最大值为 6，这就意味着 5 无法用当前两个基数的线性关系表达，这就意味着 5 也必然为素数
2:  4   6   10
   (3) (5) 
1:  2   3   5
# 继续，我们得到最大值 10。然后将当前最小值，维度 2 进行线性增加，直到不再最小。
# 这里 2 乘以 3 等于 3 * 2，已经存在，二者等价。我们都用大数来表示和小数的关系，也就是 2*3 表示成 3*2。
# 这样，所有关系数的最大关系，就变成了自身的平方。平方可以看出是关系的结界，和大数的关系视为未来，不可知。
4:  8
3: {6}  9
2:  4   6   10  14
   (3) (5) 
1:  2   3   5   7
# 事实上，无需大于（等于）其他维度的值，只要累积值和其他维度的值连续即可。
# 如上，7 已经无法用基数  2  3  5 进行线性表达。因此 7 也必然是素数。
# 然后继续，可以得到
4:  8
   (7)
3: {6}  9
2:  4   6   10  14
   (3) (5) 
1:  2   3   5   7
# 再次将最小值的维度进行累积得到 10。一方面，10 会用 5*2 来表示；另一方面，此时维度 3 变成了最小值
5: {10}
4:  8
   (7)
3: {6}  9
2:  4   6   10  14
   (3) (5) 
1:  2   3   5   7
# 将维度 3 进行线性扩展，得到 12。之后 10 又变为最小值，但它同时作为维度 2 和 5 的最大值，因此，两个维度同时扩展
5: {10}
4:  8   12
   (7)
3: {6}  9
2:  4   6   10  14
   (3) (5) 
1:  2   3   5   7
# 然后，我们得到下面的关系。同时也得到了新的素数 11
6: {12}
   (11)
5: {10}
4:  8   12
   (7)
3: {6}  9   15
2:  4   6   10  14
   (3) (5) 
1:  2   3   5   7
# 继续，得到 13
7: {14}
   (13)
6: {12}
   (11)
5: {10}{15}
4:  8   12
   (7)
3: {6}  9   15
2:  4   6   10  14  22   26
   (3) (5) 
1:  2   3   5   7   11   13
# 再继续，得到 17
9: {18}
   (17)
8:  16
7: {14}
   (13)
6: {12} 18
   (11)
5: {10}{15}
4:  8   12  20
   (7)
3: {6}  9   15  21
2:  4   6   10  14  22   26   34
   (3) (5) 
1:  2   3   5   7   11   13   17
```



上面的过程描述了素数的生成方式。但是，由于素数满足累积性，却又不满足周期性。这就意味值，每个素数的生成

* 一方面，都依赖过往的数

* 另一方面，又无法用规律（公式）来描述。

  注：所有的规律都可描述成是对某个“基” 的重复计算。重复就是循环、就是缩放。



进一步对上面的过程进行总结，可以总结出下面的规律

```python
    18(3*6)    (5*5)    (7*5)    (11*7)
16  12(3*4)  20(5*4)    (7*4)    (11*5)
8   9 (3*3)  15(5*3)  21(7*3)    (11*3)
4   6 (3*2)  10(5*2)  14(7*2)  22(11*2)  26   34
2   3        5        7        11        13   17
```



用 js 语言来实现这个过程

```javascript
let UpTo = 100,
    P = [[2/* primer-val */, 0/* primer-pos */, 2/* relation-max */]],
    PQ = [[2]],
    n = 2, d, p, m, v, i, j, k;

for(;n<UpTo;d=false) { 
  
    //（以 2 为单位）累积迭代
    n+=2;

    // 和所有（已知的）素数维度的并行进行协同
    // 因为存在多个素数维度需要同时协同推进的情况
    for(i=P.length;i--;) {
      
      // 如果累积值（达到或）超过该素数维度的并行进度
      // 此时也说明协同出现了不一致的情况
      if (n >= (m=(p=P[i])[2/* relation-max */])) {

        // 首次计算新的素数
        // 由于需要对多个素数维度进行协同，所有素数计算只需计算一次
        if (!d) {

          // 获取潜在的素数值
          v = n - 1;

          // 判定潜在的素数值是否是素数维度的关系数
          if (v === m) d=true;
          else for(j=i;j--;) if (P[j][2/* relation-max */] === v) { d=true; break; }

          //  如果不是关系数，说明肯定是素数
          if (!d) {
            PQ.push([v, j = 2 * v]);
            P.push(v = [v, d=P.length, j, 1]);
            for(;d--;) v.push(0);
          }
        }

        /// 将当前素数维度的并行进度向前推进
        
        // 对于维度 2
        if (i===0) {
          PQ[0].push(m*=2); p[2/* relation-max */] = m;
        }
        // 对于其他维度
        else {

          // 计算下一个高维关系数（对应的索引）
          m = PQ[k=0][p[3]];
          for(j=1;j<=i;++j) {
            if ((v = PQ[j][p[3+j]]) < m) {  m = v;  k = j; }
          }
          ++p[3+k];

          // 记录下一个高维关系数
          PQ[i].push(m *= p[0/* primer-val */]);
          p[2/* relation-max */] = m;

        }
      }
    }
}

// 输出
for(i=0;i<P.length;++i)
  document.write((i?', ':'') + P[i][0]);
```



上面的算法还可以进一步优化。因为，自然数是以 2 为单位迭代的，而当每次迭代时，对于奇数都会遍历一次素数，并确定该奇数不是素数的合数。因此，可以在素数维度协同扩展时，直接跳过所有的奇数。这样，每次迭代时，所有的素数维度的最大值都必然是偶数。



## 自然进制

我们可以将自然数以某个固定数量为单位进行分级，也就是我们说的进制。默认情况下，我们以10为单位进行进位计算。除此之外，在计算机中，我们更常使用的是 2、8 或 16进制。

对应的，根据素数的协同新生特性，我们完全可以将素数也看成是一种进制。和所有其他进制不同，它不是以固定数量为单位的。不过，这却构成了素数作为进制与其他进制的最大不同，即素数进制的“单位”是唯一的，而其他进制的单位则是人为规定的，可以是任意的。

因此，我们可以将素数进制看成是自然进制。它的进位条件是：“新累积的数值无法用已有的素数维度进行线性表达”